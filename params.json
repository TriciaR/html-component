{
  "name": "html-component",
  "tagline": "Component-based UIs with vanilla ES6 and Custom Elements",
  "body": "# HTML Component\r\nBuild component-based UIs without frameworks, just vanilla ES6 and Custom Elements.\r\n\r\n## What?\r\nYou know how in frontend frameworks like React/Angular/Vue you can split your entire UI in small, self-contained components?\r\nIt turns out you can get a similar kind of organization without any framework, using native Custom Elements.\r\n\r\n## Why?\r\nSplitting a complex page into small, self contained components is really helpful for ease of maintenance. If that's all you're interested, you shouldn't need to pull a framework for that.\r\nFrontend frameworks can be really helpful, but they have their own share of problems: the payload size, lack of control, leaky abstractions, vendor lock-in, steep learning curve, etc.\r\nIn the meantime, browsers are implementing Web Components natively and some parts of it, like Custom Elements, have polyfills stable enough that can be used in production today.\r\n\r\n## How does it look?\r\nHere's a sample component from the canonical Todo application:\r\n\r\n```javascript\r\nclass TodoItem extends HTMLComponent {\r\n\r\n  template(props) { return html`\r\n    <input type=\"checkbox\" ${ props.done ? 'checked' : '' }>\r\n    <input type=\"text\" class=\"desc\" readonly value=\"${props.desc}\" />\r\n    <button class=\"remove\">${icons.remove}</button>\r\n  `}\r\n\r\n  init() {\r\n    this.render()\r\n    .on('click', '.remove', e => this.publish('remove'))\r\n    .on('dblclick', '.desc', e => this.edit(e))\r\n    .on('keyup', '.desc', e => this.save(e))\r\n    .on('focusout', '.desc', e => this.render())\r\n  }\r\n\r\n  edit(e) {\r\n    e.target.removeAttribute('readonly')\r\n    e.target.focus()\r\n  }\r\n\r\n  save(e) {\r\n    if (e.keyCode == 13)\r\n      this.set({ desc: e.target.value })\r\n  }\r\n}\r\n\r\nTodoItem.styles = csjs`\r\n  :host {\r\n    display: block;\r\n    width: 100%;\r\n    padding: 7px;\r\n    background: white;\r\n    border: 1px solid whitesmoke;\r\n  }\r\n\r\n  :host[done=true] .desc[readonly] {\r\n    text-decoration: line-through;\r\n  }\r\n\r\n  input.desc {\r\n    width: 85%;\r\n    font-size: 14px;\r\n  }\r\n\r\n  .remove {\r\n    display: none;\r\n    background: transparent;\r\n    font-size: 16px;\r\n    border: none;\r\n    padding: 4px;\r\n    cursor: pointer;\r\n    float: right;\r\n    color: ${theme.red};\r\n  }\r\n`\r\n\r\nTodoItem.register('todo-item')\r\n\r\n```\r\n\r\nYou can check the complete components for more details: [todo-list](https://github.com/felipeccastro/html-component/blob/master/src/todo-list.js), [todo-item](https://github.com/felipeccastro/html-component/blob/master/src/todo-item.js) and [todo-summary](https://github.com/felipeccastro/html-component/blob/master/src/todo-summary.js).\r\n\r\n## Components\r\nThe guidelines for building maintainable components with this approach are more or less similar to what we see in other frameworks:\r\n\r\n- keep components small and focused\r\n- single file components: template + behavior + styles together (group by feature, not by technology)\r\n- parent components can communicate with child components, but without accessing their inner DOM\r\n- child components only emit events to notify parents, avoid modifying parents directly\r\n- sibling components don't talk to each other\r\n\r\nThe easiest way of seeing these principles all in practice is reading the sample Todo App implementation in this repo.\r\n\r\n## How does it work\r\n`HTMLComponent` is a small base class wrapping the native `HTMLElement`.\r\nIt provides a few helpers to make it easier to adopt this style of development:\r\n\r\n- shortcuts for common DOM methods (like `this.on('click', ...)` and `this.publish('some-event')`)\r\n- support for event delegation, so components can be re-rendered without losing their events\r\n- `.get()` and `.set()` based on html attributes (similar to \"props\" in React)\r\n- changes to props automatically re-render components, greatly reducing the amount of manual DOM manipulation necessary\r\n- html and csjs tagged template helpers for enabling syntax highlighting\r\n- styles get scoped to the custom element, e.g. `h1 { color: red }` becomes `todo-item h1 { color: red }`\r\n\r\n## Dependencies\r\n- [document-register-element.js](https://github.com/WebReflection/document-register-element) (Custom Elements v1 polyfill): not required for Chrome\r\n- [dom4.js](https://github.com/WebReflection/dom4) (DOM4 methods polyfills): optional, but makes it way easier to work with the DOM\r\n- [polyfill.io](https://polyfill.io/v2/docs/): optional, builds custom ES5 polyfills for older browsers.\r\n\r\n## Build\r\nIf you're developing on Chrome latest, *no build step is necessary*. No file watchers, no just in time compilation, just run ES6 natively.\r\nFor production (`npm run build`), this project uses `Babel` to compile ES6 to ES5 and `postcss` to add vendor prefixes to the component styles.\r\n\r\n## Editor\r\nHaving templates, styles and behaviors in the same js file can be challenging to some editors.\r\nThe screenshot above was taken with Atom on the default javascript syntax, which automatically uses the html syntax highlighting for tagged template strings using a tag called `html`.\r\nFor css, I'm using the `csjs` syntax highlighting and autocomplete, but not the actual tagged template helper.\r\n\r\n## Getting Started\r\nClone this project and modify it as you wish!\r\n\r\n## FAQ\r\n\r\n### Oh great, another MVC framework...\r\nThis is not a framework, much less MVC. This is more like a boilerplate web project with some very optionated development approaches.\r\n\r\n### How is it different from React/Angular/Vue...?\r\nThese frameworks all have built their own non-standard model of components, parallel to the native browser functionalities.\r\nThey also build on the approach of abstracting the DOM and having a state/model object being the single source of truth, leaving the DOM manipulation entirely to the framework. While there are benefits to this approach, it also comes with a cost.\r\nUsing vanilla Custom Elements and ES6 means the DOM is the source of truth, and you'll manipulate it directly, but don't panic! Not only the DOM api is much better to work with these days, but having it split over components that can be easily re-rendered from a template also makes it much simpler to build powerful UIs.\r\n\r\n### Why not Polymer?\r\nI like very much of the idea behind Polymer, having a small framework on top of all the 4 Web Components technologies (Templates, HTML Imports, Shadow DOM and Custom Elements) and overall push the adoption of Web Standards. However, the framework is entirely dependent on the stability of the polyfills, and some technologies are harder to polyfill than others (like Shadow DOM, for example). It also doesn't inspire a lot of confidence the fact that until today, not all browsers have agreed to implement all of these technologies. They did agree to implement Custom Elements v1, though, so depending only on that seems like a safe ground to proceed.\r\n\r\n### What about performance? Is it webscale(TM)?\r\nYou'll have complete control over what happens on the DOM, so how fast it is depends on how well you know vanilla javascript.\r\nThe main polyfill, document-register-element, is based on native  MutationObservers (which is pretty fast), so there's no inherent technical reason for this approach to have performance issues.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}